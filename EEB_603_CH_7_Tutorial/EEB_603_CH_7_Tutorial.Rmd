---
title: "Chapter 7 Tutorial: Tidying Your Data"
output: learnr::tutorial
runtime: shiny_prerendered
---

```{r setup, include=FALSE}
library(learnr)
library(knitr)
library(tidyverse)
library(lubridate)
library(readr)
knitr::opts_chunk$set(echo = FALSE)
```


## Before You Start

### Objectives

Learners will be able to convert data between two formats, long and wide.
Learners will be able to summarize data in R using 


### Timeline

Day 1

  * Introduction and Objectives
  
  * Explore 3 Data Cleaning Topics
  
  * Summary, Resources, Quiz
  
Day 2

  * Quick Review and Q&A
  
  * Explore 3 Advanced Cleaning Topics
  
  * Summary, Resources, Quiz

### Getting Set Up

*All of the functions will be able to run in this tutorial without opening RStudio.  When you have finished the tutorial, you will want to try some of these techniques on your own data.  The functions we run for this tutorial are supported by the tidyr and dplyr packages.  Install and load these packages before tidying your own data.*


## Day One: Pivoting Your Data
Imagine your friend in a much cooler Biology department does some awesome research on cheetahs and what characteristics make them so super fast! They want to make you a co-author on this great cheetah paper if you can just make sense of the data. They send you the data and you decide to take a look.

```{r Cheetah1, message=FALSE, warning=FALSE}
CheetahLong<-read.csv("./Messy_CSVs/Cheetas_long.csv")[,-1]
```

```{r Cheetah2, exercise=TRUE}
#Examine the data
dim(CheetahLong) #look at the dimensions
CheetahLong[sample(1:400,10),] #look at 10 rows at random
```

We can see that the data is in long format, where there are different variables all mashed together in a `value` column and the identity of those variables is in the adjacent `measurement` column. This kind of data is really difficult to do statistics on or plot. 

Let's check out the different measurements

```{r Cheetah3, exercise=TRUE}
unique(CheetahLong$Measurement)
```

We want to make the data into wide format where `NumberSpots`, `MaxSpeed`, `Birthday`, and `CelebratesBirthday` each get their own column.




## Day One: Summarizing Data

This section will help you practice some of the basic commands to get summary information about your data.  You will also learn how to subset data in order to get summary information on more manageable pieces of data.

The following dataset shows some life history information on 330 zoo animal species found in North American zoos (Che-Castaldo et al. 2019)


```{r zoo1, message=FALSE, warning=FALSE}

zoo <- read.csv(file = "Messy_CSVs/zoo.csv")

```

First we want to get a handle on this data set.  There are a lot of functions that help us see the data: dim, head, tails, names, str, summary, just to list a few.

```{r zoo2, exercise=TRUE}
#Examine the data

dim(zoo) #look at the dimensions

#Shows the first 10 rows
head(zoo)

#shows the last 10 rows
tail(zoo)

```

Sometimes it is helpful use the previous functions to put the dataset into context, especially if it is not one you created yourself.

So now that you see the dimensions and a glimpse at the start and end of the data, lets use some others.  In this next set, you get to practice with the code!

```{r zoo3, exercise=TRUE}
#Look at the structure of the data (zoo).  Run the chunk to see the output.  Press the hint button if needed.

```
:::{#zoo3-hint}
**Hint:** str(zoo)
:::

```{r zoo4, exercise=TRUE}
#Look at the summary of the data (zoo).  How is this different from the structure?

```

:::{#zoo4-hint}
**Hint:** summary(zoo)
:::

```{r zoo5, exercise=TRUE}
#Look at the names of the data (zoo).  See any that could be combined?

```

:::{#zoo5-hint}
**Hint:** names(zoo)
:::
  
Filtering the data will allow you to combine and exclude columns if you need to tidy your data to be more refined.  In this next section we will combine two columns using "unite" and we will exclude data using "-".

Notice that the ID column and Sample column have parts of one unique sample identifier.  Lets unite these two columns and give the column a new name "Sample ID".

We can also pull just the mean life expecancy data out by excluding the columns we don't want to see.

```{r zoo6, exercise=TRUE}
#Filtering the data lets combine ID and Sample using the unite function.
#We can also exclude columns so we can focus on MLE (mean life expectancy), we do this by using the - sign and indicating the column location.

zoo2 <- zoo %>%
  # new column name, ID and sample column being united, separating the values with an underscore
  unite(Sample_ID, ID, Sample, sep="_") %>%
  
  # excluding columns 7 through 18 using the select function and the - sign
  select(-7:-18)

#We can use the names functions to see the new column names
names(zoo2)

```

Now we have a unique ID for each observation and we pulled out only the data we were interested in summarizing.  Now lets organize the data by TaxonClass.  This will put all our mammals, birds, and reptiles together so we can compare.

```{r zoo7-setup}
zoo2 <- zoo %>%
  unite(Sample_ID, ID, Sample, sep="_") %>%
  select(-7:-18)
```

```{r zoo7, exercise=TRUE}
zoo2%>% arrange(TaxonClass)


```

:::{#zoo7-hint}
**Hint:** summary(zoo2)
:::

Now that we have the taxon groups organized, lets arrange the maximum life expectancy within each taxon. (arrange(primary order, secondary order))

```{r zoo8-setup}
zoo2 <- zoo %>%
  unite(Sample_ID, ID, Sample, sep="_") %>%
  select(-7:-18)
```

```{r zoo8, exercise=TRUE}
# use the arrange function with TaxonClass and Overall.MLE



```

:::{#zoo8-hint}
**Hint:** zoo2 %>% arrange(TaxonClass, Overall.MLE)
summary(zoo2)
:::

Do you notice how the data is arranged now, ascending or descendin? 

Let's change the order from ascending MLE to descending using the - sign in front of Overall.MLE.

```{r zoo9-setup}
zoo2 <- zoo %>%
  unite(Sample_ID, ID, Sample, sep="_") %>%
  select(-7:-18)
```

```{r zoo9, exercise=TRUE}


```
:::{#zoo9-hint}
**Hint:** zoo2 %>% arrange(TaxonClass, -Overall.MLE)
summary(zoo2)
:::

Great Job!  Now you can summarize, sort, and filter your data into a nice tidy package!

## Day One: Dealing with NA's

Let's imagine that you're helping the health center out with some COVID-19 data analysis. They send you the data and you check it out.
```{r Covid1, message=FALSE, warning=FALSE}
CovDat<-read.csv("./Messy_CSVs/COVID_NAs.csv")[,-1]
```


```{r Covid2, exercise=TRUE}
#Examine the data set
dim(CovDat) #look at the dimensions
CovDat #scroll through
```

What do you notice by looking through the data?

We can see a variety of different ways they have stored NAs!

It look like there's: NA, nan and -999

## Day One: Summary and Quiz

### Recap

### Resources

Data Wrangling Cheat Sheet

https://rstudio.com/wp-content/uploads/2015/02/data-wrangling-cheatsheet.pdf

### Follow-up Videos

![](https://www.youtube.com/watch?v=jOd65mR1zfw)

![](https://www.youtube.com/watch?v=1ELALQlO-yM)

### Quiz

*This quiz is not for a grade, but a helpful guide to what you know and things you might brush up on.*


```{r quiz}
quiz(
  question("Which format is your data in when the columns are variables and the rows are observations?",
    answer("short"),
    answer("wide"),
    answer("long", correct = TRUE),
    answer("tall")
  ),
  question("Which function helps to convert data from wide to long format  by when the user identifies a key and value?",
    answer("gather", correct = TRUE),
    answer("spread"),
    answer("transpose"),
    answer("reshape")
  ),
   question("Which command gives the basic descriptive stats and types for all the variables in a dataframe?",
    answer("summary", correct = TRUE),
    answer("summarize"),
    answer("stats"),
    answer("grid")
  ),
   question("Which command would denote including data that is not missing?",
    answer("!is.na", correct = TRUE),
    answer("!"),
    answer("is.na"),
    answer("na", correct = TRUE)
  ),
   question("Which of the R packages listed below are used to help tidy data?",
    answer("tidyr", correct = TRUE),
    answer("learnr"),
    answer("ggplot2"),
    answer("tidyverse", correct = TRUE)
  )
  
)
```

## Day Two: Merging Data

Imagine you are the regional manager of Winco in Idaho. One thing you might want to do is combine the data from Boise and Idaho Falls. Let's start with data on how many customers visited each location, on each day in 2020. 

### Examine each dataset
Start by looking at the Boise location and examine the dimensions.

```{r Win1, message=FALSE, warning=FALSE}
Winco1<-read.csv("./Messy_CSVs/MergeData/WincoMerge1.csv")[,-1]
```

```{r win1L, exercise=TRUE}
#Examine the Boise data set
dim(Winco1) #look at the dimensions
head(Winco1) #look at the first 6 rows
```

Then look at the Idaho Falls location and examine the dimensions of that dataset too

```{r Win2, message=FALSE, warning=FALSE}
Winco2<-read.csv("./Messy_CSVs/MergeData/WincoMerge2.csv")[,-1]
```

```{r Win2L, exercise=TRUE}
#Examine the Idaho Falls data set
dim(Winco2) #look at the dimensions
head(Winco2) #look at the first 6 rows
```

### Merge with `rbind`
We can see that these two datasets have the same number of columns and the same column names. This is the most simple way to merge data.

We can stack these two datasets on top of each other using the `rbind` command.
```{r rbindreal, message=FALSE, warning=FALSE}
allWinDat<- rbind(Winco1,Winco2)
```

```{r WinComb1, exercise=TRUE}
allWinDat<- rbind(Winco1,Winco2)

dim(allWinDat) #look at the dimensions

#examine the head and tail to make sure it worked

head(allWinDat,n=3) #first three rows
tail(allWinDat,n=3) #last three rows
```

### Merge with `merge`

Now imagine that we get another dataset which contains the financial data for each location on each day. Let's first look at it. 

```{r Win3, message=FALSE, warning=FALSE}
Winco3<-read.csv("./Messy_CSVs/MergeData/WincoMerge3.csv")[,-1]
```

```{r win3L, exercise=TRUE}
#Examine the Boise data set
dim(Winco3) #look at the dimensions
head(Winco3) #look at the first 6 rows
```

Notice that this data has the same dates and locations as the dataset we just created using `rbind`. We will want to merge the data we just created with this new dataset and make sure that the rows are all in the right place. We can do that with the `merge` command.

```{r winMerge, exercise=TRUE}
WincoFull<-merge(allWinDat,Winco3, by=c("Date","Location"))

#check it out to make sure it worked
dim(WincoFull) #check out the dimensions
head(WincoFull,n=10) #first 10 rows
```

Awesome! We got out datasets all merged!

## Day Two: Dates
As graduate students, we all know that Boise State does not provide us with dental coverage. Being the quantitative, calculated genius you are, you decide to start tracking when and for how long you brush your teeth. You plan to use this to find the optimum brush time and never get a cavity again!

The only downside is that you made this dataset before you learned about recording tidy data. Let's check it out.

```{r brush1, message=FALSE, warning=FALSE}
Brush<-read_csv("./Messy_CSVs/ToothBrushingData_Dates_Times.csv")[,-1]
```

```{r brush2, exercise=TRUE}
Brush
```

### Dates with `lubridate`

The `lubridate` package in R has a **ton** of useful functions for dealing with dates and times. The ones we will use here are the various `dmy`, `mdy`, `ydm`, etc... functions.

These functions take vectors of dates that are organized in an order that corresponds to the function letter order:

* d = day
* m = month
* y = year

Here's an example
```{r brush3, exercise=TRUE}
x<-"10-31-2020" #lets add a date with month-day-year order
lubridate::mdy(x)
```
Now let's try it with our ugly date vector

```{r brush4, exercise=TRUE}
lubridate::dmy(Brush$Date)
```

Awesome! That was easy!

### The Ugliest Dates of Them All

The most difficult date data to deal with is heterogeneous date data.

Take the following date vector

```{r brush5, exercise=TRUE}
x <- c("4th of July 1999", "1999/4/7", "4-1999-7")
x
```

That's pretty bad. But, we can deal with it easily with `lubridate`.
We will use the `parse_date_time` function. This function allows us to input the various date formats as a vector. Let's try it out.

```{r brush6, exercise=TRUE}
x <- c("4th of July 1999", "1999/4/7", "4-1999-7")
parse_date_time(x, c("dmy","ydm","dym")) 
```

### How R thinks about dates
Days in R are stored as the number of days since 1970-01-01

We can explore this with the `as_date` function
```{r brush7, exercise=TRUE}
as_date(1)
```

```{r brush8, exercise=TRUE}
as_date(47894)
```

**Important** Excel and Google Sheets actually do the same thing, but they start at 1900-01-01. For this reason, you need to be VERY careful when converting dates from R to Excel/Google Sheets and vie versa. 

## Day Two: Times
To get to the bottom of our tooth brushing problem, we're going to have to do some math with the times. Let's look at the data again.

```{r brush9, exercise = TRUE}
Brush
```

Times are stored in R as the number of seconds since 00:00:00

Let's explore that with the `hms` function in `lubridate`

* h = hours
* m = mins
* s = seconds

```{r brush10, exercise=TRUE}
t <- hms::as_hms(85) 
t
```

We can do the same thing with our Brush data. Let's see if it can check how long each observation is from 00:00:00

```{r brush11, exercise = TRUE}
hms(Brush$StartBrush)

```


Now imagine that we made a mistake and these times were all recored in PM. We can convert these with the `parse_date_time` function again. We will use a different syntax this time though.

Here, we'll tell lubridate how we are storing our time data as follows:

* %I: Hours as decimal number (01–12 or 1–12).
* %M: Minute as decimal number (00–59 or 0–59).
* %S: Second as decimal number (00–61 or 0–61).
* %P: AM/PM indicator in the locale. 

```{r brush12, exercise = TRUE}
t<-paste(Brush$StartBrush, "PM") #we need to add PM onto our times
parse_time(t, '%I:%M:%S %p')  #now we can read them as pm times

```

Lastly, let's add on the total time that we brushed our teach in each observation. We can do this in seconds only or in hms format.

```{r brush13, exercise = TRUE, warning=FALSE, message=FALSE}
Brush$totalTime1<-Brush$EndBrush-Brush$StartBrush
Brush
```

```{r brush14, exercise = TRUE, warning=FALSE, message=FALSE}
Brush$totalTime1<-hms(Brush$EndBrush)-hms(Brush$StartBrush)
Brush
```

## Day Two: Summary and Quiz

### Recap

### Resources

### Follow-up Videos

![](https://www.youtube.com/watch?v=Zc_ufg4uW4U)

### Quiz


## Session Information
```{r sessioninfo, echo=FALSE}

sessionInfo()

```

